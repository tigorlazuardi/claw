syntax = "proto3";

package claw.v1;

import "buf/validate/validate.proto";
import "claw/v1/device.proto";
import "claw/v1/nsfw.proto";
import "claw/v1/pagination.proto";
import "claw/v1/source.proto";

// DeviceSortField defines the fields that can be used for sorting devices
enum DeviceSortField {
  DEVICE_SORT_FIELD_UNSPECIFIED = 0;
  DEVICE_SORT_FIELD_ID = 1;
  DEVICE_SORT_FIELD_SLUG = 2;
  DEVICE_SORT_FIELD_NAME = 3;
  DEVICE_SORT_FIELD_HEIGHT = 4;
  DEVICE_SORT_FIELD_WIDTH = 5;
  DEVICE_SORT_FIELD_ASPECT_RATIO_DIFFERENCE = 6;
  DEVICE_SORT_FIELD_NSFW = 7;
  DEVICE_SORT_FIELD_CREATED_AT = 8;
  DEVICE_SORT_FIELD_UPDATED_AT = 9;
}

// DeviceService provides CRUD operations for devices
service DeviceService {
  // Create a new device
  rpc CreateDevice(CreateDeviceRequest) returns (CreateDeviceResponse);

  // Get a device by ID
  rpc GetDevice(GetDeviceRequest) returns (GetDeviceResponse);

  // Update an existing device
  rpc UpdateDevice(UpdateDeviceRequest) returns (UpdateDeviceResponse);

  // Delete a device
  rpc DeleteDevice(DeleteDeviceRequest) returns (DeleteDeviceResponse);

  // List devices with optional filtering
  rpc ListDevices(ListDevicesRequest) returns (ListDevicesResponse);

  // Get device dropdown options (slug and name pairs)
  rpc ListDropDownDevices(ListDropDownDevicesRequest) returns (ListDropDownDevicesResponse);

  // Subscribe a device to sources
  rpc SubscribeDevice(SubscribeDeviceRequest) returns (SubscribeDeviceResponse);

  // Unsubscribe a device from sources
  rpc UnsubscribeDevice(UnsubscribeDeviceRequest) returns (UnsubscribeDeviceResponse);
}

// Create device request
message CreateDeviceRequest {
  // url and filesystem friendly name. required.
  string slug = 1 [(buf.validate.field).string.min_len = 1];

  // Display name for the device (optional)
  string name = 2 [(buf.validate.field).string.min_len = 1];

  // Device screen height in pixels
  int32 height = 3 [(buf.validate.field).int32.gt = 0];

  // Device screen width in pixels
  int32 width = 4 [(buf.validate.field).int32.gt = 0];

  // Acceptable aspect ratio difference as between device and image.
  //
  // The values are calculated by comparing the aspect ratios of the device
  // and the image. If the absolute difference between these two ratios is
  // less than or equal to the specified aspect_ratio_difference, the image
  // is considered a match for the device.
  //
  // For example, if a device has an aspect ratio of 16:9 (approximately 1.78)
  // and an image has an aspect ratio of 16:10 (1.6), the absolute difference
  // is |1.78 - 1.6| = 0.18. If the aspect_ratio_difference is set to 0.2,
  // this image would be considered a match for the device.
  // Set value to 0 to require exact aspect ratio match.
  //
  // Recommended value is between 0.1 to 0.3 to allow images that matches the device
  // close enough that "stretching" or "fill" scaling modes will not distort
  // or crop the image too much. A value of 0.2 is a good starting point for most devices.
  double aspect_ratio_difference = 5 [(buf.validate.field).double.gte = 0];

  // Template for filename generation (optional). Can use Go template syntax.
  //
  // TODO: document available variables for the template
  //
  // If null or empty, the default filename template will be used.
  optional string filename_template = 7;

  // Minimum image height in pixels
  //
  // Set to null or value of 0 to disable validation.
  optional uint32 image_min_height = 8;

  // Minimum image width in pixels
  //
  // Set to null or value of 0 to disable validation.
  optional uint32 image_min_width = 9;

  // Maximum image height in pixels
  //
  // Set to null or value of 0 to disable validation.
  optional uint32 image_max_height = 10;

  // Maximum image width in pixels
  //
  // Set to null or value of 0 to disable validation.
  optional uint32 image_max_width = 11;

  // Minimum image file size in bytes
  //
  // Set to null or value of 0 to disable validation.
  optional uint32 image_min_filesize = 12;

  // Maximum image file size in bytes
  //
  // Set to null or value of 0 to disable validation.
  optional uint32 image_max_filesize = 13;

  // NSFW content handling mode
  NSFWMode nsfw = 14 [(buf.validate.field).enum.defined_only = true];

  // Whether the device is disabled. Disabled devices will not be assigned new images.
  optional bool is_disabled = 15;

  // List of source IDs to automatically subscribe this device to
  repeated int64 sources = 100;
}

// Create device response
message CreateDeviceResponse {
  // The created device
  Device device = 1;

  repeated int64 sources = 2;
}

// Get device request
message GetDeviceRequest {
  // Device ID to retrieve
  int64 id = 1 [(buf.validate.field).int64.gt = 0];
}

// Get device response
message GetDeviceResponse {
  // The requested device
  Device device = 1;

  int32 image_count = 2;

  repeated Source sources = 3;
}

// Update device request
message UpdateDeviceRequest {
  int32 id = 1;

  // Updated display name (optional)
  optional string name = 3;

  // Updated device screen height in pixels (optional)
  optional int32 height = 4;

  // Updated device screen width in pixels (optional)
  optional int32 width = 5;

  // Updated acceptable aspect ratio difference (optional)
  optional double aspect_ratio_difference = 6;

  // Updated filename template (optional)
  optional string filename_template = 8;

  // Updated minimum image height (optional)
  optional uint32 image_min_height = 9;

  // Updated minimum image width (optional)
  optional uint32 image_min_width = 10;

  // Updated maximum image height (optional)
  optional uint32 image_max_height = 11;

  // Updated maximum image width (optional)
  optional uint32 image_max_width = 12;

  // Updated minimum image file size (optional)
  optional uint32 image_min_filesize = 13;

  // Updated maximum image file size (optional)
  optional uint32 image_max_filesize = 14;

  // Updated NSFW content handling mode (optional)
  optional NSFWMode nsfw = 15;
}

// Update device response
message UpdateDeviceResponse {
  // The updated device
  Device device = 1;
}

// Delete device request
message DeleteDeviceRequest {
  // Device Slugs to delete.
  repeated int32 ids = 1;
}

// Delete device response
message DeleteDeviceResponse {}

// List devices request
message ListDevicesRequest {
  // Optional filter by slug
  optional string slug = 1;

  // Search term to filter devices by id, slug, or name
  optional string search = 2;

  optional bool count_images = 3;

  // Optional filter by source ID. If set, only devices subscribed to the given
  // source ID will be returned.
  optional uint32 source_id = 4;

  message LastImage {
    // Whether to include the last assigned image for each device
    optional bool include = 1;
    // If set, only include last image if it matches the given NSFW mode
    optional NSFWMode nsfw = 2;
  }

  optional LastImage last_image = 5;

  message Sort {
    // Field to sort by
    DeviceSortField field = 1 [(buf.validate.field).enum.defined_only = true];
    // Whether to sort in descending order
    bool desc = 2;
  }

  // Fields to sort by.
  repeated Sort sorts = 99;

  // Pagination parameters. Use the same sort fields
  // and then set this to previous response's pagination
  // to get the next page or previous page of results.
  //
  // Changing sort fields while paginating may lead to
  // unexpected results.
  //
  // If user changes sort fields, client should reset
  // by using empty tokens.
  optional Pagination pagination = 100;
}

// List devices response
message ListDevicesResponse {
  message Item {
    Device device = 1;
    optional int64 image_count = 2;
  }
  // List of devices
  repeated Item items = 1;
  Pagination pagination = 2;
}

// List dropdown devices request
message ListDropDownDevicesRequest {
  // Empty message
}

// List dropdown devices response
message ListDropDownDevicesResponse {
  message Item {
    int32 id = 1;
    string name = 2;
  }
  // List of device dropdown options
  repeated Item items = 1;
}

// Subscribe device request
message SubscribeDeviceRequest {
  // Device ID to subscribe
  int64 device_id = 1 [(buf.validate.field).int64.gt = 0];

  // List of source IDs to subscribe to
  repeated int64 source_ids = 2 [(buf.validate.field).repeated.min_items = 1];
}

message SubscribeDeviceResponse {}

// Unsubscribe device request
message UnsubscribeDeviceRequest {
  // Device ID to unsubscribe
  int64 device_id = 1 [(buf.validate.field).int64.gt = 0];

  // List of source IDs to unsubscribe from
  repeated int64 source_ids = 2 [(buf.validate.field).repeated.min_items = 1];
}

// Unsubscribe device response
message UnsubscribeDeviceResponse {
  // The updated device with remaining subscriptions
  Device device = 1;
}
